===============================================================================
  HANDOVER NOTES — Reportheld REST API Prototype
===============================================================================

  For:        The next team rotating into this project
  From:       OJT Team — February 2026
  Estimated onboarding time:  ~20 minutes

===============================================================================


WHAT THIS IS
───────────────────────────────────────────────────────────────────────────────

  A working prototype of a self-hosted REST API that acts as a secure
  bridge between external tools (e.g., n8n, AI agents) and Reportheld's
  core domain logic.

  It exposes one domain-driven endpoint:
    POST /api/v1/protocol-executions

  It does NOT modify Reportheld itself.


HOW TO RUN IT (< 5 MINUTES)
───────────────────────────────────────────────────────────────────────────────

  Prerequisites: Node.js 18+, Docker Desktop (running)

  1.  cp .env.example .env
  2.  docker compose -f data/docker-compose.yml up -d
  3.  npm install
  4.  npm start
  5.  Open http://localhost:4001 in your browser


ASSUMPTIONS WE MADE
───────────────────────────────────────────────────────────────────────────────

  1.  Reportheld's protocol execution can be modeled as a simple state
      machine: initialized → in_progress → completed (or rejected).

  2.  Tenant isolation is sufficient at the API key level for a prototype.
      Production will need deeper integration with Reportheld's user/group
      system.

  3.  Webhooks are "fire and forget" — no retry mechanism, no delivery
      guarantee. This is acceptable for a demo but NOT for production.

  4.  The API does not actually connect to Reportheld. Protocol execution
      is fully simulated with timed status transitions.

  5.  PostgreSQL is the right choice for structured execution records.
      This differs from the initial Decision Memo which mentioned MongoDB.
      We chose PostgreSQL for its relational structure and ACID guarantees.


WHAT WORKS
───────────────────────────────────────────────────────────────────────────────

  - API key validation with tenant derivation
  - Protocol execution creation with 201 response
  - Status lifecycle simulation (initialized → in_progress → completed)
  - Signed webhook events (HMAC-SHA256)
  - Built-in webhook receiver for testing
  - HTML test UI at /index.html
  - Docker-based PostgreSQL with auto-table creation


WHAT DOES NOT WORK / IS INCOMPLETE
───────────────────────────────────────────────────────────────────────────────

  - No real Reportheld integration (everything is simulated)
  - No webhook retry on failure
  - No "rejected" status simulation
  - No rate limiting
  - No request logging / audit trail
  - API keys are static in .env (no management API)
  - No automated tests


OPEN QUESTIONS (For the next team)
───────────────────────────────────────────────────────────────────────────────

  1.  How should the API authenticate with Reportheld's actual backend?
      Does Reportheld expose internal APIs we can call?

  2.  Should webhook URLs be registered per-tenant (stored in DB) or
      provided per-request as we do now?

  3.  What is the real status lifecycle in Reportheld? We assumed
      initialized → in_progress → completed → rejected, but is there
      a "queued" or "paused" state?

  4.  Should there be a GET endpoint to check execution status, or is
      webhook-only sufficient for external consumers?

  5.  How many concurrent executions should the API support? Does this
      affect the database schema (e.g., indexing)?


WHERE THINGS LIVE
───────────────────────────────────────────────────────────────────────────────

  server.js                          Express entry point
  db.js                              PostgreSQL connection + table init
  controllers/                       Request handling + webhook logic
  middleware/                         API key validation
  models/                            SQL queries
  routes/                            Route definitions
  public/index.html                  Test UI
  data/docker-compose.yml            PostgreSQL container
  docs/                              Decision log, domain explanation, etc.
  .env.example                       Environment template


THINGS THAT FELT WRONG (Documenting honestly)
───────────────────────────────────────────────────────────────────────────────

  - setTimeout for status simulation is fragile. In production, this
    should be event-driven or queue-based.

  - Storing API keys in .env as JSON is awkward to manage. A database
    table or config file would be cleaner at scale.

  - The webhook receiver is built into the same server. In real usage,
    webhooks go to external systems. This is fine for demo but could
    confuse someone reading the code for the first time.


===============================================================================
  END OF HANDOVER NOTES
===============================================================================
