===============================================================================
  PROPOSED IMPROVEMENTS — For Future Versions
===============================================================================

  These are concrete, prioritized improvements for the next iterations
  of the Reportheld REST API. Each item includes what, why, and rough
  effort level.

===============================================================================


PRIORITY: HIGH (Should be in v2)
───────────────────────────────────────────────────────────────────────────────

  1.  JWT Authentication
      ─────────────────────────────────────────────────────────────────
      What:   Replace static API keys with JWT tokens
      Why:    Supports token expiry, refresh, scoped permissions
      Effort: Medium (add token issuance endpoint, verify middleware)
      Note:   Keep API key support for backward compatibility

  2.  Webhook Retry with Exponential Backoff
      ─────────────────────────────────────────────────────────────────
      What:   Retry failed webhook deliveries up to N times with delay
      Why:    Webhook receivers may be temporarily down
      Effort: Medium (needs a queue or retry table in the database)
      Note:   Log all delivery attempts for debugging

  3.  GET /api/v1/protocol-executions/:id
      ─────────────────────────────────────────────────────────────────
      What:   Allow consumers to check execution status on demand
      Why:    Fallback for missed webhooks, debugging, UI dashboards
      Effort: Low (simple query by ID with tenant scoping)

  4.  Rate Limiting
      ─────────────────────────────────────────────────────────────────
      What:   Limit requests per API key (e.g., 100 req/min)
      Why:    Prevents abuse, protects database
      Effort: Low (express-rate-limit middleware)

  5.  Request/Response Logging
      ─────────────────────────────────────────────────────────────────
      What:   Log all API requests with timestamp, API key, status
      Why:    Audit trail, debugging, security monitoring
      Effort: Low (morgan middleware or custom logger)


PRIORITY: MEDIUM (v2 or v3)
───────────────────────────────────────────────────────────────────────────────

  6.  OpenAPI / Swagger Documentation
      ─────────────────────────────────────────────────────────────────
      What:   Auto-generated API docs from route definitions
      Why:    Makes the API self-documenting for consumers
      Effort: Medium (swagger-jsdoc + swagger-ui-express)

  7.  Role-Based Scopes
      ─────────────────────────────────────────────────────────────────
      What:   API keys have scopes (e.g., execute:protocols, read:status)
      Why:    Granular permission control per integration
      Effort: Medium (extend API key map, check scopes in middleware)

  8.  Webhook URL Registration (Per-Tenant)
      ─────────────────────────────────────────────────────────────────
      What:   Tenants register webhook URLs in advance instead of
              providing them per-request
      Why:    More secure (URLs are pre-approved), simpler request body
      Effort: Medium (new table, management endpoint)

  9.  Database Migrations
      ─────────────────────────────────────────────────────────────────
      What:   Use a migration tool (e.g., node-pg-migrate) instead of
              auto-creating tables in code
      Why:    Safer schema evolution, rollback support
      Effort: Low-Medium

  10. Automated Test Suite
      ─────────────────────────────────────────────────────────────────
      What:   Integration tests for all endpoints
      Why:    Catch regressions, validate behavior on changes
      Effort: Medium (Jest + supertest)


PRIORITY: LOW (v3+, Nice to Have)
───────────────────────────────────────────────────────────────────────────────

  11. Pagination for List Endpoints
      ─────────────────────────────────────────────────────────────────
      What:   GET /api/v1/protocol-executions with cursor-based paging
      Why:    Needed when execution count grows
      Effort: Low

  12. Health Check Endpoint
      ─────────────────────────────────────────────────────────────────
      What:   GET /health returning DB connection status
      Why:    Useful for monitoring, load balancers, Docker health checks
      Effort: Very Low

  13. "Rejected" Status Simulation
      ─────────────────────────────────────────────────────────────────
      What:   Simulate failed/rejected executions for testing
      Why:    External systems need to handle failure cases too
      Effort: Low (add to the status transition logic)

  14. Containerize the API Server
      ─────────────────────────────────────────────────────────────────
      What:   Add a Dockerfile for the Node.js API (not just Postgres)
      Why:    Single docker-compose up starts everything
      Effort: Low

  15. MCP Layer Integration
      ─────────────────────────────────────────────────────────────────
      What:   Wrap the API as an MCP tool for AI agents
      Why:    Enables AI systems to trigger protocol executions
      Effort: Medium-High (depends on MCP specification)


===============================================================================
  END OF PROPOSED IMPROVEMENTS
===============================================================================
