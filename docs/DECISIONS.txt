===============================================================================
  DECISION LOG — Reportheld REST API Prototype
===============================================================================

  Project:  Self-Hosted REST API for Reportheld
  Date:     February 2026
  Authors:  OJT Team

===============================================================================


1. ENDPOINT CHOICE
───────────────────────────────────────────────────────────────────────────────

  Decision:   Expose a single domain-driven endpoint
              POST /api/v1/protocol-executions

  Why:        Protocol execution is the highest-value capability for external
              automation. It represents a domain action ("start a protocol"),
              not a database operation. This aligns with the API-as-product
              principle from the OJT Charter.

  Rejected:   CRUD endpoints for protocols, templates, items.
              Reason: Exposes internal domain structure and increases
              attack surface without proportional value.


2. DATABASE: POSTGRESQL
───────────────────────────────────────────────────────────────────────────────

  Decision:   Use PostgreSQL as the data store.

  Why:        - Relational model fits structured execution records
              - Strong ACID guarantees for status transitions
              - Widely supported in self-hosted environments
              - Native UUID support for primary keys
              - pg (node-postgres) is a mature, minimal driver

  Rejected:   MongoDB — while flexible, relational data with clear schema
              (executions, statuses, tenants) benefits from PostgreSQL's
              structure and constraints.


3. AUTHENTICATION: STATIC API KEY MAP
───────────────────────────────────────────────────────────────────────────────

  Decision:   Use static API keys stored as a JSON map in the .env file.
              Tenant is derived server-side from the key, never client-provided.

  Why:        - Simple and auditable
              - No external auth service required (self-hosted constraint)
              - Tenant isolation is enforced at the API layer
              - Appropriate for a prototype; upgradable to JWT later

  Format:     rh_test_<tenant>_<random>  (e.g., rh_test_alpha_92f4c1)
              Prefix makes keys identifiable. Not production-strength,
              but realistic enough for demonstration.


4. WEBHOOK SIGNING: HMAC-SHA256
───────────────────────────────────────────────────────────────────────────────

  Decision:   Sign all webhook payloads with HMAC-SHA256 using a shared secret.
              The signature is sent in the X-Webhook-Signature header.

  Why:        - Industry standard (used by Stripe, GitHub, etc.)
              - Receiving systems can verify the webhook came from our API
              - Prevents injection of fake status updates
              - Simple to implement with Node.js crypto module
              - No external dependencies


5. STATUS LIFECYCLE SIMULATION
───────────────────────────────────────────────────────────────────────────────

  Decision:   Simulate the full execution lifecycle via timed transitions:
              initialized → in_progress (2s) → completed (5s)

  Why:        - Demonstrates realistic protocol behavior
              - Each transition fires a separate signed webhook event
              - External tools can react to intermediate states
              - "rejected" status exists as a concept but is not simulated
                in this prototype (future consideration)


6. NO ORM
───────────────────────────────────────────────────────────────────────────────

  Decision:   Use raw SQL via pg (node-postgres), no ORM.

  Why:        - Minimal overhead and dependencies
              - Full control over queries
              - Easier to understand and debug
              - Appropriate for a small prototype
              - Avoids introducing Sequelize/Prisma complexity


7. VERSIONED ROUTES
───────────────────────────────────────────────────────────────────────────────

  Decision:   All API routes are under /api/v1/

  Why:        - Enables backward-compatible evolution
              - Future versions (/api/v2/) can coexist
              - Industry standard practice


8. SELF-HOSTED INFRASTRUCTURE
───────────────────────────────────────────────────────────────────────────────

  Decision:   Docker Compose for PostgreSQL, Node.js for the API server.
              No cloud dependencies.

  Why:        - Non-negotiable constraint from the OJT Charter
              - Any team can run it locally with Docker + Node.js
              - Portable to on-premises infrastructure
              - No vendor lock-in


===============================================================================
  END OF DECISION LOG
===============================================================================
