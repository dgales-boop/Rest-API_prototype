DECISION LOG — Why we built it this way

1. Single endpoint: POST /api/v1/protocol-executions
   - One domain action ("start a protocol"), not CRUD. Best for automation.

2. PostgreSQL
   - Fits execution records, ACID, UUID support. We use raw SQL (pg), no ORM.

3. API keys in .env (JSON map)
   - Key → tenant. Tenant is derived server-side. Simple for prototype; can move to JWT later.

4. Status lifecycle: initialized → in_progress (2s) → completed (5s)
   - Simulated with timers. Each step sends a webhook. "rejected" exists as idea, not implemented.

5. Routes under /api/v1/
   - So we can add v2 later without breaking clients.

6. Self-hosted only
   - Docker Compose for Postgres, Node for API. No cloud deps.
