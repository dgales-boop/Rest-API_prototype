===============================================================================
  PRESENTATION & DEMO GUIDE
  Reportheld REST API — OJT Week 1 Deliverable
===============================================================================

  Use this guide to prepare for your meeting.
  Read it with your partner and decide who presents which section.

  Estimated presentation time: 10–15 minutes
  (including live demo)

===============================================================================


STRUCTURE OVERVIEW
───────────────────────────────────────────────────────────────────────────────

  1. The Problem           (1–2 min)  — Why this API exists
  2. Our Decision          (2–3 min)  — What we chose to expose and why
  3. Live Demo             (3–4 min)  — Show it working
  4. Security & Boundaries (2 min)    — What we protected
  5. What We Excluded      (1–2 min)  — What we intentionally did NOT build
  6. Handover & Next Steps (1–2 min)  — How the next team continues

  TIP: Split it. One person explains the concept (sections 1, 2, 4, 5).
       The other person drives the live demo and talks through the code
       (sections 3, 6).


===============================================================================
  SECTION 1: THE PROBLEM (1–2 min)
===============================================================================

  WHAT TO SAY:
  ──────────────

  "Reportheld is an internal system. Right now, there's no way for
  external tools — like n8n, or an AI agent — to interact with it
  securely.

  If someone wants to start a protocol execution, they have to do it
  manually inside Reportheld. There's no automation, no external
  integration, and no real-time updates.

  Our task was: can we build a secure bridge that lets external
  systems trigger meaningful actions in Reportheld, without breaking
  security or exposing internal data?"

  KEY POINT TO LAND:
  ──────────────
  The API is NOT about exposing the database. It's about exposing
  a meaningful domain action — safely.


===============================================================================
  SECTION 2: OUR DECISION (2–3 min)
===============================================================================

  WHAT TO SAY:
  ──────────────

  "We chose to expose one endpoint:

     POST /api/v1/protocol-executions

  This lets an external system say: 'Start this protocol at this site.'
  That's it. One action, one endpoint.

  We chose this because protocol execution is the highest-value
  capability for automation. An n8n workflow can trigger an inspection.
  An AI agent can request a safety check. And they get real-time updates
  back through webhooks — no polling needed.

  We did NOT expose protocol creation, template editing, user management,
  or any raw database access. Those are internal operations that would
  increase the attack surface without clear value for external consumers."

  KEY POINT TO LAND:
  ──────────────
  This is a domain-driven API, not a CRUD API. We expose what's
  valuable, not what's technically possible.

  IF THEY ASK "Why only one endpoint?":
  ──────────────
  "The charter said 'reduce uncertainty.' One well-designed endpoint
  that proves the concept is more valuable than five half-baked ones.
  We can always add more in v2 — and we documented exactly what
  should come next in our improvements doc."


===============================================================================
  SECTION 3: LIVE DEMO (3–4 min)
===============================================================================

  BEFORE THE MEETING — PREPARATION CHECKLIST:
  ──────────────────────────────────────────────

  [ ] Docker Desktop is running
  [ ] Run: docker compose -f data/docker-compose.yml up -d
  [ ] Run: npm start
  [ ] Verify http://localhost:4001 loads in your browser
  [ ] Do one test click to make sure everything works
  [ ] Have a terminal ready to show server logs side-by-side

  DEMO FLOW (talk as you do each step):
  ──────────────────────────────────────

  Step 1 — Show the Test UI
  "This is our test page. It's a simple form where you provide
  an API key, a protocol ID, a site ID, and a webhook URL."

  Step 2 — Point out the API key field
  "Notice the API key — rh_test_alpha_92f4c1. This key maps to
  tenant-alpha on the server side. The tenant is never provided
  by the client. The server derives it from the key. This is how
  we enforce tenant isolation."

  Step 3 — Click 'Execute Protocol'
  "When I click this, it sends a POST request to our API.
  The server validates the key, creates an execution record in
  PostgreSQL, and returns a 201 response with the execution ID
  and status 'initialized'."

  (Point to the API Response panel — show the JSON)

  Step 4 — Wait for webhooks
  "Now watch the Webhook Events panel. In about 2 seconds...
  there — the status changed to 'in_progress'. And in a few
  more seconds... 'completed'.

  Each of these is a webhook POST that our server sent to the
  webhook URL. In a real setup, this would go to n8n or whatever
  external system is listening."

  Step 5 — Show the terminal/server logs (if screen sharing allows)
  "You can see in the server logs: the webhook was delivered
  with a 200 status."

  IF THE DEMO BREAKS:
  ──────────────────────
  Stay calm. Say: "Let me check the server logs." Most likely
  causes: Docker not running, or port 4001 is already in use.
  If it truly fails, show the curl example from the README instead.


===============================================================================
  SECTION 4: SECURITY & BOUNDARIES (2 min)
===============================================================================

  WHAT TO SAY:
  ──────────────

  "Security was a core constraint. Here's what we did:

  1. API Key Authentication — every request needs a valid key in
     the X-API-Key header, or it gets a 401.

  2. Tenant Isolation — the tenant is derived from the key on the
     server side. A client can never claim to be a different tenant.

  3. Minimal Exposure — we only expose one action. No reads, no
     deletes, no admin operations. You can start a protocol, and
     you can receive status updates. That's it."

  IF THEY ASK "Why not JWT?":
  ──────────────
  "JWT is the right move for production — it gives us token expiry,
  refresh, and scoped permissions. But for a prototype proving the
  concept, static API keys are simpler and still demonstrate the
  tenant isolation model. JWT is in our v2 roadmap."


===============================================================================
  SECTION 5: WHAT WE EXCLUDED (1–2 min)
===============================================================================

  WHAT TO SAY:
  ──────────────

  "We documented everything we intentionally left out. The key ones:

  - No protocol creation or editing (internal operations)
  - No user management (security risk)
  - No raw database access (we're not building a database mirror)
  - No GET endpoints for now (webhooks already deliver status)

  Everything is in our EXCLUDED.txt file with reasoning for each."

  KEY POINT TO LAND:
  ──────────────
  Saying "we chose NOT to build X because Y" shows stronger
  judgment than building everything without thinking.


===============================================================================
  SECTION 6: HANDOVER & NEXT STEPS (1–2 min)
===============================================================================

  WHAT TO SAY:
  ──────────────

  "We built this to be handed over. The next team can run the
  prototype in under 5 minutes — it's Docker-based, self-hosted,
  no cloud dependencies.

  We left five documentation files:
  - Decision log — every choice and why
  - Handover notes — assumptions, open questions, honest issues
  - Domain explanation — what this represents in Reportheld
  - Excluded list — what we didn't build and why
  - Improvements — 15 prioritized items for future versions

  The biggest open question for the next team: how does this
  API actually connect to Reportheld's real backend? Right now
  everything is simulated. The architecture is ready, but the
  integration point needs to be defined."

  KEY POINT TO LAND:
  ──────────────
  "Our work survives us. Another team can pick this up and
  continue within 30 minutes — which is exactly what the
  charter asked for."


===============================================================================
  POSSIBLE QUESTIONS AND HOW TO ANSWER THEM
===============================================================================

  Read these with your partner. Decide who answers which topic.
  You don't need to memorize these word-for-word — just understand
  the idea so you can explain it naturally.

───────────────────────────────────────────────────────────────────────────────
  ABOUT THE ENDPOINT
───────────────────────────────────────────────────────────────────────────────

  Q: "Why only one endpoint?"
  A: "The charter said to expose 'the right things, not everything.'
     Protocol execution is the single highest-value capability for
     external automation. One solid endpoint is better than five
     half-finished ones. We documented what should come next
     in our improvements file."

  Q: "Why POST and not GET?"
  A: "Because we're creating something — a protocol execution.
     POST is the correct HTTP method for creating a new resource.
     GET is for reading data, which we don't expose yet."

  Q: "Why /api/v1/ in the URL?"
  A: "Versioning. If we need to change the API later — like changing
     the response format — we can create /api/v2/ without breaking
     existing integrations that still use v1. It's standard practice."


───────────────────────────────────────────────────────────────────────────────
  ABOUT SECURITY
───────────────────────────────────────────────────────────────────────────────

  Q: "How does tenant isolation actually work?"
  A: "Each API key maps to exactly one tenant. When a request comes in,
     the server looks up the key, finds the tenant, and attaches it
     to the execution record. The tenant is never provided by the
     client, so there's no way to impersonate another tenant."

  Q: "Why not JWT instead of API keys?"
  A: "JWT is the right move for production — it gives us token expiry,
     refresh, and scoped permissions. But for a prototype, static
     API keys are simpler and still demonstrate the tenant isolation
     model. JWT is in our v2 roadmap."

  Q: "What if someone steals the API key?"
  A: "That's a real concern. In production, we'd add rate limiting,
     IP allowlisting, and key rotation. For this prototype, the keys
     are only used locally. We documented these improvements for v2."

  Q: "Is this secure enough for production?"
  A: "No — and we intentionally documented what's missing. For
     production we'd need webhook signing, JWT, rate limiting, and
     HTTPS. The prototype shows the core model works — production
     hardens it."


───────────────────────────────────────────────────────────────────────────────
  ABOUT TECHNICAL CHOICES
───────────────────────────────────────────────────────────────────────────────

  Q: "Why PostgreSQL and not MongoDB?"
  A: "Protocol executions have a clear, structured schema — IDs,
     statuses, timestamps, tenant references. PostgreSQL's relational
     model and ACID guarantees are a better fit. MongoDB is great
     for flexible documents, but we didn't need that flexibility."

  Q: "What is ACID?"
  A: "It stands for Atomicity, Consistency, Isolation, Durability.
     It basically means when we update a status from 'in_progress'
     to 'completed', it either fully happens or doesn't happen at
     all — no half-updates. That's important for reliable status
     tracking."

  Q: "Why no ORM like Sequelize or Prisma?"
  A: "We wanted minimal dependencies and full control over our SQL
     queries. For a small prototype with two queries, raw SQL is
     simpler and easier to understand. An ORM adds complexity
     that isn't justified at this scale."

  Q: "Why Express and not Fastify or another framework?"
  A: "Express is the most widely used Node.js framework. It's
     well-documented, easy to understand, and any developer can
     pick it up quickly. For a prototype focused on clarity,
     it's the right choice."

  Q: "What does Docker do here?"
  A: "Docker runs our PostgreSQL database in a container. This means
     any developer can start the database with one command —
     docker compose up — without installing PostgreSQL on their
     machine. It makes the project truly portable."


───────────────────────────────────────────────────────────────────────────────
  ABOUT THE STATUS LIFECYCLE
───────────────────────────────────────────────────────────────────────────────

  Q: "Why do you simulate the status changes? Why not make them real?"
  A: "Because we're not modifying Reportheld. In a real integration,
     Reportheld itself would change the status as it processes the
     protocol. Our simulation proves the webhook mechanism works —
     the real status changes would come from Reportheld's engine."

  Q: "What about the 'rejected' status in your slides?"
  A: "It exists as a concept in our design — a protocol execution
     could fail or be rejected. We didn't simulate it in the
     prototype because the happy path was enough to prove the
     concept. Adding rejected would be straightforward."


───────────────────────────────────────────────────────────────────────────────
  ABOUT WEBHOOKS
───────────────────────────────────────────────────────────────────────────────

  Q: "What is a webhook?"
  A: "Instead of the external tool constantly asking 'is it done yet?'
     — which is called polling — our API pushes a notification to
     the external tool when something changes. It's like the
     difference between refreshing your email vs getting a push
     notification. More efficient, more real-time."

  Q: "What happens if the webhook fails?"
  A: "Right now, it logs the error and moves on. There's no retry.
     We documented this as a known limitation. In v2, we'd add
     retry with exponential backoff — try again after 1 second,
     then 2, then 4, then 8, and so on."

  Q: "How do you secure webhooks?"
  A: "Security-wise, we derived tenant ID from the API key so data is
     isolated. For message integrity, you would normally sign webhooks
     using HMAC-SHA256. We left that out of the V1 prototype to keep
     the code simple, but it is the FIRST thing we would add for V2.
     It's documented in our Improvements file."


───────────────────────────────────────────────────────────────────────────────
  ABOUT HANDOVER & NEXT STEPS
───────────────────────────────────────────────────────────────────────────────

  Q: "Can the next team actually continue this?"
  A: "Yes. We wrote the README so they can run it in under 5 minutes.
     And we have five documentation files covering our decisions,
     assumptions, open questions, what we excluded, and what should
     be built next."

  Q: "What should the next team focus on?"
  A: "The biggest gap is real Reportheld integration — right now
     everything is simulated. After that, webhook signing and
     retries are the highest-priority improvements."

  Q: "What would you do differently if you started over?"
  A: "Honestly, not much for the scope we had. If we had more time,
     we'd add a GET endpoint for checking execution status and
     automated tests. But for a Week 1 prototype, we're happy
     with the focus on one solid endpoint with proper documentation."
───────────────────────────────────────────────────────────────────────────────
  IF YOU DON'T KNOW THE ANSWER
───────────────────────────────────────────────────────────────────────────────

  It's okay. Here are professional responses:

  "That's a good question. We haven't explored that yet, but we
  documented it as an open question for the next team."

  "We considered that but decided to keep it out of v1 to focus
  on proving the core concept first."

  "That's something we'd need to investigate further — it's a
  good candidate for the v2 scope."

  NEVER make up an answer. Saying "I don't know but here's how
  I'd find out" is always better than guessing.


===============================================================================
  FINAL TIPS
===============================================================================

  1. Practice the demo once before the meeting. Make sure Docker is
     running and the server starts cleanly.

  2. Don't read from slides. Tell the story:
     Problem → Decision → Proof (demo) → Security → What's next

  3. When you show code or config, point out the WHY, not the WHAT.
     Don't say "this line creates a pool." Say "we connect to PostgreSQL
     here because structured execution records need ACID guarantees."

  4. If someone asks something you don't know, say: "That's a great
     question. We documented it as an open question in our handover
     notes for the next team." This is honest and professional.

  5. End strong. Your last sentence should be something like:
     "This prototype proves that a secure, self-hosted REST API for
     Reportheld is feasible. The next team can pick it up and build
     on it immediately."

  6. Speak with confidence. You built this. You understand why every
     piece exists. You're not presenting homework — you're presenting
     a professional prototype.


===============================================================================
  END OF PRESENTATION GUIDE
===============================================================================

